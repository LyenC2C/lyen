1.TCP
SYN（synchronous）是TCP/IP建立连接时使用的握手信号。
在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，
服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。
这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。

2.线程状态（生，可运行，运行，等待/阻塞/睡眠，死）

A、新状态：线程对象已经创建，还没有在其上调用start()方法。
B、可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。
C、运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。
D、等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。
E、死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

a、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。
b、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
c、调用join()方法：t1,t2,main
  //t1调用Thread的join方法，主函数将线程分配给t1，当t1运行完毕后，才会将线程释放出去。给其他的对象。
  //由于t1条用了join方法，t1结束后释放，t2和主函数竞争，如果主函数（main方法的操作是主线程）在t1，t2之前无论怎样都执行主线程
d、调用setPriority() : 方法线程优先级为1~10之间的正整数，JVM从不会改变一个线程的优先级。然而，1~10之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。

3.1void notify()
            唤醒在此对象监视器上等待的单个线程。
   2void notifyAll()
             唤醒在此对象监视器上等待的所有线程。
    3void wait()
              导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
a.必须从同步环境内调用wait()、notify()、notifyAll()方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。